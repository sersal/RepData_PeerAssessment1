q()
install.packages("twitteR")
install.packages("tm")
install.packages("ggplot2")
install.packages("streamR")
install.packages(c("igraph", "RColorBrewer"))
install.packages("FactoMineR")
install.packages("wordcloud")
library("twitteR")
load("cred.RData")
registerTwitterOAuth(cred)
load("cred.RData")
load("E:/La recherche/Twitter/cred.RData")
registerTwitterOAuth(cred)
sea1 <- searchTwitter("cartif",n=50)
ut <- userTimeline('barackobama', n=100)
library("streamR")
filterStream("tweets.json", track = c("Obama", "Biden"), timeout = 10,
oauth = cred)
tweets.df <- parseTweets("tweets.json", simplify = TRUE)
tweets.df
c( length(grep("obama", tweets.df$text, ignore.case = TRUE)),
length(grep("biden", tweets.df$text, ignore.case = TRUE)) )
options(RCurlOptions = list(verbose = FALSE,capath = system.file("CurlSSL", "cacert.pem", package = "RCurl"), ssl.verifypeer = FALSE))
load("cred.RData")
registerTwitterOAuth(cred)
library(twitteR)
library(tm)
library(igraph)
library(RColorBrewer)
clean.text <- function(some_txt)
{
some_txt = gsub("(RT|via)((?:\\b\\W*@\\w+)+)", "", some_txt)
some_txt = gsub("@\\w+", "", some_txt)
some_txt = gsub("[[:punct:]]", "", some_txt)
some_txt = gsub("[[:digit:]]", "", some_txt)
some_txt = gsub("http\\w+", "", some_txt)
some_txt = gsub("[ \t]{2,}", "", some_txt)
some_txt = gsub("^\\s+|\\s+$", "", some_txt)
# define "tolower error handling" function
try.tolower = function(x)
{
y = NA
try_error = tryCatch(tolower(x), error=function(e) e)
if (!inherits(try_error, "error"))
y = tolower(x)
return(y)
}
some_txt = sapply(some_txt, try.tolower)
some_txt = some_txt[some_txt != ""]
names(some_txt) = NULL
return(some_txt)
}
t           <- searchTwitter("Pope Francis",n=1000)
texto       <- sapply(t, function(x) x$getText())
texto_clean <- clean.text(texto)
corpus    <- Corpus(VectorSource(texto_clean))
skipwords <- c(stopwords("english"),"catholic","church","francis","pope",
"franciscatholic","catholics","pontiff","breaking","breaks",
"brings","called","cityso","due","franciss",
"fridayjuly","julam","julylumenfidei","julypopo","lights",
"means","much","most","news","newspope","popefrancis",
"publishedjuly","top","trying","video","wtradition")
corpus    <- tm_map(corpus, removeWords, skipwords)
tdm <- TermDocumentMatrix(corpus)
m   <- as.matrix(tdm)
wc   <- rowSums(m)
lim  <- quantile(wc, probs=0.9) # palabras por encima del tercer cuartil
good <- m[wc > lim,]
good <- good[,colSums(good)!=0]
M <- good %*% t(good)
diag(M) <- 0
# graph
g <- graph.adjacency(M, weighted=TRUE, mode="undirected",
add.rownames=TRUE)
# layout
glay = layout.fruchterman.reingold(g)
# let's superimpose a cluster structure with k-means clustering
kmg <- kmeans(M, centers=8)
gk  <- kmg$cluster
# Paleta de colores
# -----------------
gbrew <- c("red", brewer.pal(8, "Dark2"))
gpal <- rgb2hsv(col2rgb(gbrew))
gcols <- rep("", length(gk))
for (k in 1:8) {
gcols[gk == k] = hsv(gpal[1,k], gpal[2,k], gpal[3,k], alpha=0.5)
}
# RepresentaciÃ³n
# --------------
# prepare ingredients for plot
V(g)$size = 10
V(g)$label = V(g)$name
V(g)$degree = degree(g)
#V(g)$label.cex = 1.5 * log10(V(g)$degree)
V(g)$label.color = hsv(0, 0, 0.2, 0.55)
V(g)$frame.color = NA
V(g)$color = gcols
E(g)$color = hsv(0, 0, 0.7, 0.3)
# plot
plot(g, layout=glay)
title("\nGraph of tweets about genetics and genomics",
col.main="gray40", cex.main=1.5, family="serif")
q()
q()
getwd()
q()
workrFunc <- function(n){return(n^2)}
values <- 1:100
workerFunc <- function(n){return(n^2)}
values <- 1:100
res <- lapply(values,workerFunc)
print(unlist(res))
library(paralell)
library(parallel)
numWorkers <- 2
res <- mclapply(values,workerFunc,mc.cores=numWorkers)
c1 <- makeCluster(numWorkers,type="PSOCK")
c1
res <- parLapply(c1,values,workerFunc)
stopCluster(c1)
print(unlist(res))
values <- 1:10000
res <- lapply(values,workerFunc)
system.time(res <- lapply(values,workerFunc))
values <- 1:100000000
system.time(res <- lapply(values,workerFunc))
values <- 1:10000000
system.time(res <- lapply(values,workerFunc))
numWorkers <- 3
c1 <- makeCluster(numWorkers,type="PSOCK")
system.time(res <- parLapply(c1,values,workerFunc))
stopCluster(c1)
c1
q()
install.packages("stream")
library("stream", lib.loc="C:/Users/Sergio/Documents/R/win-library/3.0")
q()
install.packages("knitr")
This is an R Markdown document. Markdown is a simple formatting syntax for authoring web pages (click the **Help** toolbar button for more details on using R Markdown).
library(knitr)
When you click the **Knit HTML** button a web page will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
When you click the **Knit HTML** button a web page will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
q()
setwd("E:/Coursera//Data Science Specialization//4 - Reproducible Research//Peer Assessments//PA1//RepData_PeerAssessment1")
dir()
data <- read.csv2(file="activity.csv", header=TRUE, sep=",")
k <- is.na(data$steps)
data.new <- data
mean.steps.interval <- tapply(data$steps, data$interval, FUN=mean, na.rm=TRUE)
data.new
data.new[1:100,]
mean.steps.interval[1:10]
names(mean.steps.interval)
names(mean.steps.interval)==data.new[,3]
which(names(mean.steps.interval)==data.new[,3])
data.new[1,]
which(names(mean.steps.interval)==0)
mean.steps.interval(which(names(mean.steps.interval)==0))
mean.steps.interval[which(names(mean.steps.interval)==0)]
names(which.max(mean.steps.interval))
mean.steps.interval[which(names(mean.steps.interval)==0)]
data.new[1,]
mean.steps.interval[which(names(mean.steps.interval)==data$interval[k])]
which(k)
k[1000]
which(k)[1000]
data.new[9928,]
which(names(mean.steps.interval)==1115)
mean.steps.interval[which(names(mean.steps.interval)==1115)]
data.new[9928,1] <- mean.steps.interval[which(names(mean.steps.interval)==1115)]
data.new[9928,]
data.new[9928,1] <- mean.steps.interval[which(names(mean.steps.interval)==data.new[9928,3])]
data.new[9928,]
new.data <- data
k <- is.na(new.data$steps)
new.data[k,1] <- mean.steps.interval[which(names(mean.steps.interval)==new.data[k,3])]
new.data[1:10,]
names(new.data)
comparison <- matrix(ncol=2,nrow=2)
comparison
comparison <- matrix(ncol=2,nrow=2)
comparison[1,1] <- mean(total.steps.per.day)
comparison[2,1] <- median(total.steps.per.day)
comparison[1,2] <- mean(new.total.steps.per.day)
comparison[2,2] <- median(new.total.steps.per.day)
total.steps.per.day <- tapply(data$steps, data$date, FUN=sum, na.rm=TRUE)
new.total.steps.per.day <- tapply(new.data$steps, new.data$date, FUN=sum, na.rm=TRUE)
comparison <- matrix(ncol=2,nrow=2)
comparison[1,1] <- mean(total.steps.per.day)
comparison[2,1] <- median(total.steps.per.day)
comparison[1,2] <- mean(new.total.steps.per.day)
comparison[2,2] <- median(new.total.steps.per.day)
comparison
colnames(comparison)
colnames(comparison) <- c("mean","median")
colnames(comparison)
comparison
colnames(comparison) <- c("old dataset","new dataset")
comparison
rownames(comparison)
rownames(comparison) <- c("mean","median")
comparison
weekdays()
length(new.total.steps.per.day)
new.data[1,]
new.data[1,2]
as.data(new.data[1,2])
as.date(new.data[1,2])
as.POSIXct(new.data[1,2])
wwekday(as.POSIXct(new.data[1,2]))
weekday(as.POSIXct(new.data[1,2]))
weekdays(as.POSIXct(new.data[1,2]))
weekdays(as.POSIXct(new.data[,2]))
day <- if weekdays(as.POSIXct(new.data[1,2]))==("sábado"|"domingo") "weekend" else "weekday"
day <- if (weekdays(as.POSIXct(new.data[1,2]))==("sábado"|"domingo")) "weekend" else "weekday"
type.of.day <- function(x){
d <- weekdays(as.POSIXct(x))
if (x=="sábado"|x=="domingo")
tod <- "weekend"
else
tod <- "weekday"
return(tod)
}
new.data[1,2]
type.of.day(new.data[1,2])
type.of.day(new.data[1:10,2])
type.of.day(new.data[3,2])
type.of.day(new.data[6,2])
type.of.day(new.data[621,2])
type.of.day(new.data[622,2])
type.of.day(new.data[623,2])
type.of.day(new.data[624,2])
type.of.day(new.data[12624,2])
td <- data.frame(col.names="day type")
td
td <- lapply(new.data$date, type.of.day)
td[[1]]
td[[1:10]]
td[[2]]
td
as.factor(td)
as.factor(unlist(td))
new.data$date[1]
type.of.day("2012-10-01")
type.of.day("2014-07-16")
type.of.day("2014-07-12")
type.of.day("2014-07-17")
type.of.day("2014-07-18")
type.of.day("2014-07-19")
as.POSIXct("2014-07-18")
weekdays(as.POSIXct("2014-07-18"))
weekdays(as.POSIXct("2014-07-19"))
weekdays(as.POSIXct("2014-07-20"))
type.of.day <- function(x){
d <- weekdays(as.POSIXct(x))
if (d=="sábado"|d=="domingo")
tod <- "weekend"
else
tod <- "weekday"
return(tod)
}
td <- as.factor(unlist(lapply(new.data$date, type.of.day)))
td
table(td)
td <- sapply(new.data$date, type.of.day))
td <- sapply(new.data$date, type.of.day)
td
as.factor(td)
table(as.factor(td))
new.data <- cbind(new.data, as.factor(sapply(new.data$date, type.of.day)))
names(new.data)
names(new.data)[4]
names(new.data)[4] <- "type"
mean.steps.weekday <- tapply(data[type=="weekday"]$steps, data[type=="weekday"]$interval, FUN=mean, na.rm=TRUE)
names(new.data)[4] <- "type"
tapply(data[type=="weekday"]$steps, data[type=="weekday"]$interval, FUN=mean, na.rm=TRUE)
mean.steps.weekday <- tapply(data$steps, data$interval, FUN=mean, na.rm=TRUE)
tapply(new.data$steps, c(new.data$interval,new.data$type), FUN=mean, na.rm=TRUE)
tapply(new.data[type="weeday"]$steps, new.data[type=="Weekday"]$interval, FUN=mean, na.rm=TRUE)
length(new.data$interval)
length(new.data$type)
q()
